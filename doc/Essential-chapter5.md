# <Essential c++>——第五章
面向对象的编程风格

> class的主要用途在于引入一个崭新的数据类型，能够更直接的在所设计的程序系统中，表现我们想要表现的实体。

---

### OOP概念

- OOP两个主要特质： 继承、多态；

- **继承（inheritance）**
    - 将一群相关的类组织起来，让他们分享其间的共通数据和操作行为；
    - |--父类（基类）：定义了所有子类的共享共有接口和私有实现
    - |--子类（派生类）：每个子类可以增加或者覆盖继承来的行为；

- **多态（polymorphism）**
    - 保证我们可以在上面的基础上，再进行编程，操作某一个单一个体；
    - 让基类的pointer或者reference能够透明的指向其任何一个派生类对象；

> 在对象应用程序中，一般会间接利用指向抽象基类的pointer或者reference，来操作系统中的对象，而不是直接操作他们，这需要虚函数技术来实现。

- 抽象基类：这一继承体系中最根本的类，没有任何实体，仅仅为了设计上的需要而存在。

#### 访问类型(Y可以访问， N无法访问)
|类型 | class自身| 派生类 | 其他程序 |
|-----| -------- | ------ | -------- |
|public| Y | Y | Y |
|protect| Y | Y | N |
|private| Y | N | N |

---
### 定义一个抽象基类（[本节代码展示](../code/abstractClass/)）

- 设计一个抽象基类的步骤：
    1. **找出所有子类共通的操作行为；**
    2. **找出哪些操作行为与类型相关；** 也就是，必须根据不同的派生类而有不同的实现方式，然后把它们声明为虚函数，等待派生类覆盖。
    3. **为每个操作行为设置访问层级；**


#### 虚函数
- 定义方式： 在成员函数前面加上`virtual`关键字。

> c++在默认情况下，对函数成员的调用实施的是**静态连编（static binding）**，也叫**静态绑定**。此时，如果子类中的函数F覆盖了基类的函数F，那么**基类**中的其他函数调用函数F的时候，调用的仍然是**基类**中的这个函数F，而不是子类中覆盖的那个。

- **对于一个成员函数，我们要想实现其根据调用对象对该函数的覆盖，而改变其函数定义**，这时需要用到虚函数。

- 虚函数也是一个函数成员，他要求在子函数中对其进行覆盖。
- 对于虚函数，编译器完成的是**动态连编（dynamic binding）**，也叫**动态绑定**，因此，对虚函数的调用是在程序运行时确定的。
- 虚函数只能借助**指针**或**引用**来达到多态的效果。
- 定义为虚函数，是为了允许用户利用基类的指针来调用子类的这个函数。


一个例子
```c++
class A
{
public:
    // 一个虚函数
    virtual void foo()
    {
        cout<<"A::foo() is called"<<endl;
    }
};
class B:public A
{
public:
    // 覆盖基类的虚函数
    void foo()
    {
        cout<<"B::foo() is called"<<endl;
    }
};
int main(void)
{
    A *a = new B();
    // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的
    a->foo();
    return 0;
}
```

#### 纯虚函数
定义方式： 在虚函数定义的后面加上 `=0`。

- 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。
- 带有纯虚函数的类称为**抽象类**，它不能生成自己的对象。
- 因此，定义纯虚函数的目的在于，**实现一个接口，起到规范的作用**。该类的每一个派生类都必须实现这个函数。

一个例子
```c++
//定义一个抽象类
class People
{
protected:
    char name[50];
    int age;
public:
    People()
    {
        name[0] = age = 0;
    }
    //纯虚函数
    virtual void setData(char *,int) = 0;
};
//抽象类的子类
class Bob:public People
{
public:
    //覆盖基类的纯虚函数
    void setData(char *n,int a)
    {
        strcpy(name,n);
        age = a;
    }
    char *getName(){return name;}
    int getAge(){return age;}
};
```


#### 小结
- 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
- 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。

*所谓设计，必须来来回回地借助程序员的经验和用户的反馈演进。————Lippman*


- 一个类的数据成员，如果是以下三种情况之一的，其初始化应用 **成员初始化列表**
    - const类型
    - reference
    - 某一个其他类的对象
- 如果抽象基类具有实际的数据成员，我们需要为其提供构造函数，但是它仍然无法定义对象，该抽象基类扮演的角色是 其派生类对象的**子对象**;
- 定义派生类对象的时候，编译器会首先调用其基类的构造函数。

### 在派生类中定义虚函数
- 其函数原型必须完全符合基类中声明的函数原型，包括：**参数列表、返回值类型、常量性**；
- 派生类中，关键字virtual并非必要；

**虚函数的静态解析**：
- 在基类的构造函数中，派生类的虚函数绝对不会被调用；

**多态 需要的间接性**
> 在c++中，只有使用基类的pointer和reference，才能够支持OOP编程的概念。


### 运行时的类型鉴定机制（RTTI）
- Run-Time Type Identification (RTTI)：能够让我们查询多态化的class pointer和class reference，获取其所指对象的实际类型
```c++
#include<typeinfo>
// 定义一个派生类的对象f1
fib f1;
num_seq *ps = &f1；
if(typeid(*ps) == typeid(fib))
    // OK, 上述条件成立
```

回顾这个工程中我们实现函数`what_am_i()`的代码，是通过返回一个事先定义好的字符串来实现的。
其实还有一个办法：
```c++
#include<typeinfo>
// 此时，该函数在基类中不再是纯虚的，
inline const char* num_seq::what_am_i() const {
    return typeid(*this).name();
}
```

注意：
通过`typeid()`输出自定义类型的名称的时候，返回的字符串的第一个元素是这个名字的长度。比如：
```c++
fib f1;
cout << typeid(f1).name;
```
输出 `3fib`。可以使用下面的方式解决：
```c++
fib f1;
const char *temp1 = f1.what_am_i_typeid();
cout << ++temp1;
```
