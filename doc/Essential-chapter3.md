# 《Essential c++》——第三章

泛型编程风格

### 泛型编程（[本节代码展示](../code/genericVector.cpp)）

- STL的两种组件：容器、泛型算法；
- 泛型算法与他要操作的元素的类型无关，其使用【函数模板】技术，达到【与操作对象的类型相互独立】的目的；
- 思想：不要直接在容器身上进行操作。而是由一对iterator标示要进行迭代的范围。指示容器读取操作终点的值（其最后一个元素的下一个地址）被称为【标兵】；
- vector和array容器中，都是以一块连续内存来存储其所有元素。而list中的元素是以一组指针相互链接成的。分为前向指针和后向指针；

>这本书的3.1节中，第一段代码有点问题，在codeblocks下面编译出错。原因是第一个形参他声明为了const类型，在函数内部他又将这个变量返回了，但是定义的函数返回值却不是const的。因此编译报错。解决方法可以在函数的定义时，将返回值类型改为const。
>

### 泛型指针--iterator
每一个标准容器都会提供一个名为``begin（）``的操作函数，该函数返回一个iterator，指向容器的第一个元素；``end（）``操作函数指向最后一个元素的下一个位置；

- 定义iterator:
```c++
vector<string> svec;
vector<string>::iterator iter = svec.begin();
```

**解释**：定义``iter``为一个iterator， 其指向vector，且该vector的元素类型为string， ``iter``其初值指向svec的第一个元素；通过iterator调用底部的string元素所提供的操作时，可以使用【箭头运算符``->``】；通过迭代器取得元素值的时候，采用指针的取用方式。 


### 使用泛型算法
- 包含头文件 ``algorithm``；
- 泛型算法中的每个函数的参数基本上都是接收泛型指针，常常使用每个容器的``begin（）``或者``end（）``操作来返回需要的指针。

### 设计泛型算法
function object 这一节没有看懂。后续补充上。


### 使用map
- map被定义为一对数值对，一个key对应一个value；
- 定义方式： 
```c++
map<string, int> words;
words["andrew"] = 25;
```
- map对象有一个``first``成员，对应key。另一个``second``成员，对应value；当使用中括号操作符``[ ]``查询某个key是否存在于map中时，如果这个key不存在，那么这个操作之后，该key会被自动添加到这个map中，并给出默认值0；
- 可以使用``find（）``函数或者``count（）``函数来进行查找某个key；``find（）``返回这个key的一个iterator， ``count（）``返回这个key在map中出现的次数

### 使用set
- set由一群key组成，其中的元素会依据其所属类型默认的less-than运算符进行排列，并自动去除重复的元素；
- 如果想知道某个值是否被遍历过，可以将所有遍历过的值存放于一个set中，然后每次遍历之前都查找一下他是否存在于这个set之中。set的检索效率比较高；

### 使用iostream iterator
这一章没什么好说的，把iterator应用到iostream中，获取标准输入输出 或者 文件的输入与输出。
