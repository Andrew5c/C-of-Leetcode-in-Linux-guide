# 《Essential c++》——第二章
面向过程的编程风格

### 函数参数调用方式（[本节代码示例](../code/essential/callFunction.cpp)）
* 三种函数参数的传递方式：**值传递、指针传递、引用传递**；
* 参数声明为reference（引用）
例如： ``void fun(int &val);``

> 面对reference的所有操作都和面对【reference所代表的对象】所进行的所有操作一致。
> ``int m;int &n = m;``这里建立了n对m 的引用，n是m的一个别名，注意n既不是m的拷贝，也不是他的指针，其实n就是m自己。
- 在某些函数不会对参数做改变的情况下，可以将参数定义为【常引用】，const会保护参数在函数内不被改变，reference可以降低复制大型对象产生的额外负担。

#### 指针和引用之间的重要差异：
* 指针可能（也可能不）指向某个实际的对象，所以使用指针时，最好判断一下是否为``NULL``；而引用必定会代表某个对象；
* 引用被创建的时候必须被初始化，指针则不必；
* 一旦引用关系被建立，就不能改变这个引用关系；而指针则可以任意指向；
> 1、 所以，我觉得reference可以理解为弱化版的指针，因为指针有时候太【锋利】了。
> 2、 其实引用能做的事情，指针也能做，但是引入reference的概念的原因就是【用适当的工具做适当的工作】，能用reference就不用指针，避免发生意外。

### 动态内存管理
* 分配程序的空闲空间，也称为【堆内存 heap memory】；
* 由``new``表达式完成内存申请，返回指向该内存的一个【指针】；
* 使用``delete``释放不用的内存，如果最后不进行``delete``，那么可能产生【内存泄露】；

### 提供默认参数
* c++中，对函数默认参数的解析是从最右边开始的，如果对左边的某个参数提供了默认值，那么它右边的所有参数都必须提供默认值。【因此，有默认值的参数可以放在参数列表的最右侧】；
* 在函数的声明和定义中，默认值只能够指定一次。我们一般放在【头文件中的函数声明处】；

### 声明inline函数
* 只需要在函数前面加上【inline】关键字即可；
* 编译器将inline函数的调用改为一份函数代码副本替代，使得各个模块之间的耦合性更小，但是不增大函数调用的开销；
* 一般小体积，常使用的函数，声明为inline比较好；
* 且inline函数的定义，常常放在头文件中；

### 提供重载函数(overlord function)
* 参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同;
* 多个函数的返回值和函数名相同，但是参数列表不同，以实现函数的多样性使用；
* 函数返回值也不能作为重载的依据;
* 编译器会根据调用者给出的实参，来和每个重载函数的参数对比，找出最适合的那个；

#### c++如何实现重载?
`C++代码在编译时会根据参数列表对函数进行重命名，例如void Swap(int a, int b)会被重命名为_Swap_int_int，void Swap(float x, float y)会被重命名为_Swap_float_float。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。`


### 定义使用模板函数
* 在函数头上面加上``template <typename Type>``；
* 其中，Type是用户自定义的任意名称，代表一个占位符，表示某种数据类型；
* 函数模板就是将参数列表中指定的全部（或者部分）参数类型抽离了出来，提高函数的可复用性；

### 函数指针（[本节代码示例](../code/essential/functionPoint.cpp)）
* 定义时，函数指针必须指明其所指函数的返回类型和参数列表；【比如： ``int* (*funPtr) (int)``， 表示funPtr指针可以指向所有返回值为 ``int*``，且参数列表中只有一个int的函数】；
* 其调用方式和一般函数的调用相同；
* 当需要定义一个**函数指针数组**的时候，数组中存放每个函数的地址。可以顺便定义一个【枚举】类型，用于辅助记忆数组中各个函数的位置。【因为当你需要 特定 使用某个名字的函数时，你可能需要去数一数这个函数名在数组中的 索引值，然后用下标去取这个函数地址。但是如果顺便按照数组中函数地址的顺序定义一个枚举类型的话，后面就可以直接使用 枚举 中的名字来索引你想要的那个函数地址】
