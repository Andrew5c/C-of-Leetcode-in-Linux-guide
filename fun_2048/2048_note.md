# <2048>代码笔记

## namespace
### 有名namespace
- 对代码进行封装，避免与标准库中的名称冲突


### 无名namespace
- 将代码限定在本文件内部，相当于C中的static关键字起到的作用。因为没有name，所以无法在其他文件中using。

**Tips**
- 在枚举类型中，最后一个枚举常量可以作为前面所有枚举常量的一个计数标志，比如`menu.cpp`文件中开头定义的枚举类型。


### 使用`using`别名语法替代`typedef`
- typedef 重定义类型很方便，但是却无法重定义模板。比如，我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。它一次只能定义一个类型的变换：
```c++
typedef std::map<std::string, int> myMap1;
typedef std::map<std::string, std::string> myMap1;
```
因此，在c98中，常常使用外面包裹一个结构体来进行模板的重定义，略显繁琐！
```c++
    template <typename Val>
    struct str_map
    {
        typedef std::map<std::string, Val> type;
    };
    // ...
    str_map<int>::type map1;
    // ...
```
- 利用 `using`替代`typedef`，对模板进行类型的重定义。
```c++
template <typename val>
using myMap_t = std::map<std::string, val>;
myMap_t<int> map_t;
```

### 前向声明
- 比如标准头文件`iosfwd`，提供输入输出流的前向声明
 
- 可以声明一个类而不定义它。这个声明，有时候被称为前向声明(forward declaration)。- 在声明之后，定义之前，类Screen是一个不完全类型(incompete type)，即已知Screen是一个类型，但不知道包含哪些成员。
- 不完全类型只能以有限方式使用，不能定义该类型的对象.
- 不完全类型只能用于定义指向该类型的指针及引用，或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数。
```c++
class A;
class B
{
  public:
      A* m_a; //不能A m_a，也即是不能定义A的对象
}
```

### `auto`关键字
- auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。
- auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。
#### 用法
1. 用于代替冗长复杂、变量使用范围专一的变量声明。

想象一下在没有auto的时候，我们操作标准库时经常需要这样：
```c++
#include<string>
#include<vector>
int main()
{
    std::vector<std::string> vs;
    for (std::vector<std::string>::iterator i = vs.begin(); i != vs.end(); i++)
    {
        //...
    }
}
```
使用auto能简化代码：
```c++
#include<string>
#include<vector>
int main()
{
    std::vector<std::string> vs;
    for (auto i = vs.begin(); i != vs.end(); i++)
    {
        //..
    }
}
```
for循环中的i将在编译时自动推导其类型。

2. 在定义模板函数时，用于声明依赖模板参数的变量类型。
```c++
template <typename _Tx,typename _Ty>
void Multiply(_Tx x, _Ty y)
{
    auto v = x*y;
    std::cout << v;
}
```

3. 模板函数依赖于模板参数的返回值
```c++
template <typename _Tx, typename _Ty>
auto multiply(_Tx x, _Ty y)->decltype(x*y)
{
    return x*y;
}
```

### lambda函数
- 用来创建匿名函数，`lambda`是c++11中引入的一项新技术，用以替换独立函数或者函数对象。增强代码的可读性。

- 广义上来说，lambda表达式产生的函数对象
- 在类中，如果重载了函数调用运算符`()`，此时，这个类的对象就具有了类似函数的行为，称这类对象为**函数对象，或者仿函数**。


引入 lambda 表达式的前导符是一对方括号，称为 lambda 引入符（lambda-introducer）。lambda 引入符是有其自己的作用的，不仅仅是表明一个 lambda 表达式的开始那么简单。lambda 表达式可以使用与其相同范围 scope 内的变量。这个引入符的作用就是表明，其后的 lambda 表达式以何种方式使用（正式的术语是“捕获”）这些变量（这些变量能够在 lambda 表达式中被捕获，其实就是构成了一个闭包）

### `constexpr`指针
- c++11中新增加的定义常量表达式的关键字。
- 由`constexpr`修饰的常量表达式，其值在编译阶段即被确定。

#### `constexpr`与`const`的区别
- `const`修饰的值可以在运行时确定。



### 错误记录
#### 使用`c++11`标准编译出错
在CMakeLists文件中设置使用c++11标准，编译结果如下。
```c++
In file included from /home/anc/qs/my-Leetcode/fun_2048/src/menu.cpp:2:0:
/home/anc/qs/my-Leetcode/fun_2048/./src/headers/global.hpp:45:52: error: ‘dataSuppliment’ function uses ‘auto’ type specifier without trailing return type
 auto dataSuppliment(suppliment_t data, function_t f) {
                                                    ^
/home/anc/qs/my-Leetcode/fun_2048/./src/headers/global.hpp:45:52: note: deduced return type only available with -std=c++14 or -std=gnu++14
/home/anc/qs/my-Leetcode/fun_2048/src/menu.cpp: In function ‘bool {anonymous}::oneLoop()’:
/home/anc/qs/my-Leetcode/fun_2048/src/menu.cpp:72:80: error: invalid use of ‘auto’
                                   Game::Graphics::Menu::mainMenuGraphicsOverlay));
                                                                                ^
CMakeFiles/2048.dir/build.make:75: recipe for target 'CMakeFiles/2048.dir/src/menu.cpp.o' failed
make[2]: *** [CMakeFiles/2048.dir/src/menu.cpp.o] Error 1
CMakeFiles/Makefile2:72: recipe for target 'CMakeFiles/2048.dir/all' failed
make[1]: *** [CMakeFiles/2048.dir/all] Error 2
Makefile:83: recipe for target 'all' failed
make: *** [all] Error 2
```

### `enum`与``enum class`的区别
- `enum`不限定作用域
- `enum class`是c++11中引入的新关键字，对枚举类型进行限定作用域
枚举类型（enum）的成员的可见范围被提升至该枚举类型所在的作用域内，这样有可能污染了外部的作用域。
```c++
enum text{
    boy, girl
}
```
上面的枚举类型定义了`boy`和`girl`的枚举变量，因为他们不限定作用域，所以，同一文件下面无法再定义`boy`和`girl`的枚举变量。而`enum class`可以。


### 多个文件中定义同名namespace的作用
- 虽然可以写在同一个文件中，但是为了增强代码的可读性，将不同功能的代码进行分类处理。
- 对于两个头文件A和B，如果其中都含有一个同名的namespace，比如说game，那么他们其实就是相当于写在同一个文件中的namespace。也就是他们其中的变量和函数可以相互调用，而不用加上对namespace的使用（前提是包含了对应的头文件）。


### 系统时间
- 使用方式 ： `std::chrono::high_resolution_clock::now();`
- `std::chrono`是c++11引入的日期时间处理库，其中包含3种时钟：`system_clock`，`steady_clock`，`high_resolution_clock`。


### `tuple`元组
- 可以理解为`pair`的扩展，**用来将不同类型的元素放在一起，常用于函数的多返回值**。
- 可以使用初始化列表来进行赋值。
- 当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。
- `std::tuple`理论上可以有无数个任意类型的成员变量。
- `std::pair`只能是2个成员，因此在需要保存3个及以上的数据时就需要使用`tuple`元组。

- `std::make_tuple`用来创建一个tuple对象，能够从参数类型推断出目标类型。

#### 一个例子
tuple的元素类型为引用：
```c++
std::string name;
std::tuple<string &, int> andrew(name, 24);
std::get<0>(andrew) = "name-andrew";
std::cout << "name" << name << "\n";
```

使用vector作为tuple的元素：
```c++
struct tile_t
{
    ull value{};
    bool blocked{};
};
using tile_data_array_t = std::vector<tile_t>;
using gameboard_data_array_t = std::tuple<size_t, tile_data_array_t>;
```
这里的`size_t`?
- `size_t`是一种无符号的整型数，它的取值没有负数，在数组中也用不到负数;
- 而它的取值范围是整型数的双倍。sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型;
- 该类型保证能容纳实现所建立的最大对象的字节大小;
- size_t是无符号的，并且是平台无关的，表示0-MAXINT的范围;
`typedef unsigned int size_t`


### 'std::tie'关键字
- `tie`将变量的引用整合成一个`tuple`，从而实现批量的赋值
```c++
using namespace std;
tuple<int,double,string> t3 = {1, 2.0, '3'};
int i; double j; string k;
tie(i, j, k) = t3;
```
- 注意tie无法从初始化列表中获取值。

### `explicit`关键字？
- 用来修饰类的构造函数，表明构造函数是显示的，相对的是`implicit`关键字。
- 只能用在类内部的构造函数声明上，而不能用在类外部的函数定义上，它的作用是不能进行隐式转换。也就是将编译器隐式转换的功能给屏蔽掉。


